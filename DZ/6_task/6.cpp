#include <iostream>
#include <ctime>
#include <cassert>

/*

Мурашко И А АПО - 13
Даны неотрицательные целые числа n, k и массив целых чисел из диапазона [0..109] размера n.
Требуется найти k-ю порядковую статистику. т.е. напечатать число, которое бы стояло на позиции с индексом k ∈[0..n-1] в отсортированном массиве.
Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n).
Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент.
Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j. Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
6_3. Реализуйте стратегию выбора опорного элемента “случайный элемент”. Функцию Partition реализуйте методом прохода двумя итераторами от начала массива к концу.
Ввод											Вывод
10 4
1 2 3 4 5 6 7 8 9 10
												5
*/



template <class T>
int find_static (T * Array, int n, int k ){
    int position = 0;
    int buffer_n = n;
    while (position < n){
        if(n == 1){
            return Array[0];
        }
        if (position == buffer_n - 2){
            return Array[buffer_n - 1];
        }

        int pivot = rand() % (n  - position ) + position;
        if (pivot != n - 1) {
            std::swap(Array[n - 1], Array[pivot]);
        }
        int j = position;
        int i = position;
        while (i < n - 1){
            if (Array[i] < Array[n-1]){
                std::swap(Array[i], Array[j]);
                i++;
                j++;
            } else {
                i++;
            }
        }
        std::swap(Array[j],Array[n - 1]);

        if(j < k){
            position = j + 1;
        } else if (j > k) {
            n = j;
        } else {
            return Array[j];
        }
    }
    return -1;

}
int main(){
    int n = 0, k = 0;

    assert(k >= 0 && n >= 0);
    std::cin >> n >> k;
    int * Array = new int [n];
    for (int i = 0; i < n; i++ ) {
        std::cin >> Array[i];
    }
    std::cout << find_static(Array, n, k);
    delete[] Array;
    return 0;
}
